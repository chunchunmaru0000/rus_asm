вход глав

участок чит изм
;	buffer db 256 dup(0)
	пусть текст байт запас 0 256

участок чит исп

глав:
    ; Читаем строку с клавиатуры
    быть рди 0          ; stдиn
    быть рси текст	     ; адрес буфера
    быть рдх 256        ; размер буфера
    быть рах 0          ; sys_read
    сзов

    ; Длина строки в рах, сохраняем её
    быть рсх рах        ; рсх = длина введённой строки
    быть рди текст      ; адрес начала буфера
    зов to_upper   ; преобразуем строку в верхний регистр

    ; Выводим строку на экран
    быть рди 1          ; stdout
    быть рси текст	     ; адрес буфера
    быть рдх рсх        ; длина строки
    быть рах 1          ; sys_write
    сзов

    ; Завершаем программу
    искл рди рди        ; код возврата 0
    быть рах 60         ; sys_exit
    сзов

; Функция преобразования строки в верхний регистр
; рди - адрес строки, рсх - длина строки

; Функция для преобразования строки в верхний регистр
; Входные параметры:
; RDI - адрес строки
; RCX - длина строки
to_upper:
    толк рди           ; сохраняем адрес строки
    толк рсх           ; сохраняем длину строки

    искл рах рах       ; обнуляем RAX
    искл рдх рдх       ; обнуляем RDX

loop_sтрing:
    быть аг байт (рди) ; загружаем текущий символ
    проб аг аг        ; проверяем на ноль (конец строки)
    ид0 end_procессиng  ; если достигли конца строки, завершаемся

    ; Первый байт в юникода из двух байтов начинается с 110
    ; Проверка первого байта
    срав аг 0б11000000 ; 0xC0       ; начало двухбайтового символа в UTF-8
    идп сгeck_latin     ; если меньше, то это однобайтовая латинская буква

    ; последующие байты юникода с 10 начинаются
    ; Проверка второго байта
    быть ал байт (рди 1)
    срав ал 0б10000000 ; 0x80       ; проверяем, является ли второй байт частью двухбайтового символа
    идп сгeck_latin     ; если нет, то это однобайтовый символ

    ;срав ах, 1101000010010000b ; А русская
    ;идп loop_next
    срав ах 0б1101000110010001 ; ё
    идр convert_yo
    
    срав ах 0б1101000110001111 ; я русская(Я РУССКИЙ)
    идв loop_next

    срав ах 0б1101000010101111 ; Я русская
    идв sтрoсгnaya
    
    
    ;110 10000 10 111111 ; п
    ;110 10000 11 000000 ; уже не юникод
    ;110 10001 10 000000 ; р
    
    
    ; тут если и так заглавная делать нечего
    ;увлч рди
    ;увлч рди ; ну типа два байтаиникодных
    плюс рди 2
    идти loop_sтрing

sтрoсгnaya:
    срав ах 0б1101000010111111 ; п
    идв mилиe_tan_p_sтрoсгnaya
    
    сиmple_sтрoсгnaya:
        минс ах дбайт 0х20 ; -32 для перевода
        идти end_ruссian_symbol
    
    mилиe_tan_p_sтрoсгnaya:
        минс ах дбайт 0хИ0  ; 225 потому что сдвиг 193 для сохранени 10 второго байта и еще + 32 = 225; 00000000 11000001b
        идти end_ruссian_symbol


convert_yo:
   быть ах 0б1101000010000001

end_ruссian_symbol:
; можно попробовать
; быть дбайт [рди], ах
    быть байт (рди) аг
    быть байт (рди 1) ал
    плюс рди 2         ; двигаемся на два байта вперед
    идти loop_sтрing



сгeck_latin:
    ; Проверка латинской буквы
    срав аг "a"        ; начало диапазона строчных латинских букв
    идп loop_next       ; если меньше, то пропускаем
    срав аг "z"        ; конец диапазона строчных латинских букв
    идв loop_next       ; если больше, то пропускаем

    ; Преобразование в верхний регистр
    минс аг 32         ; для перевода строчной латинской буквы в заглавную
                       ; нужно вычесть 32

    ; Запись измененного байта обратно в строку
    быть байт (рди) аг

loop_next:
    увлч рди            ; двигаемся на один байт вперед
    идти loop_sтрing

end_procессиng:
    выт рсх            ; восстанавливаем длину строки
    выт рди            ; восстанавливаем адрес строки
    возд               ; возвращаемся из функции

